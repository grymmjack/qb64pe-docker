name: 'QB64PE Multi-Platform Build'
description: 'Build QB64PE projects for Linux, macOS, and Windows with automatic releases'
author: 'grymmjack'

branding:
  icon: 'code'
  color: 'blue'

inputs:
  source-file:
    description: 'Path to the .bas source file to compile (relative to workspace)'
    required: true
  project-name:
    description: 'Name of your project (used for artifacts and releases)'
    required: true
  qb64pe-version:
    description: 'QB64PE version to use'
    required: false
    default: 'v4.3.0'
  platform:
    description: 'Target platform: linux, macos, or windows'
    required: true

outputs:
  artifact-name:
    description: 'Name of the uploaded artifact'
    value: ${{ steps.set-names.outputs.artifact-name }}
  executable-name:
    description: 'Name of the compiled executable'
    value: ${{ steps.set-names.outputs.executable-name }}

runs:
  using: 'composite'
  steps:
    - name: Set platform-specific names
      id: set-names
      shell: bash
      run: |
        PLATFORM="${{ inputs.platform }}"
        PROJECT="${{ inputs.project-name }}"
        
        if [ "$PLATFORM" = "windows" ]; then
          EXECUTABLE="${PROJECT}.exe"
          ARCHIVE="${PROJECT}-win-x64.zip"
        elif [ "$PLATFORM" = "macos" ]; then
          EXECUTABLE="${PROJECT}"
          ARCHIVE="${PROJECT}-osx-x64.tar.gz"
        else
          EXECUTABLE="${PROJECT}"
          ARCHIVE="${PROJECT}-lnx-x64.tar.gz"
        fi
        
        echo "executable-name=${EXECUTABLE}" >> $GITHUB_OUTPUT
        echo "artifact-name=${ARCHIVE}" >> $GITHUB_OUTPUT
        echo "EXECUTABLE=${EXECUTABLE}" >> $GITHUB_ENV
        echo "ARCHIVE=${ARCHIVE}" >> $GITHUB_ENV
    
    - name: Install QB64PE (Linux)
      if: inputs.platform == 'linux'
      shell: bash
      run: |
        docker pull ghcr.io/grymmjack/qb64pe-docker:${{ inputs.qb64pe-version }} || \
        docker build --build-arg QB64PE_VERSION=${{ inputs.qb64pe-version }} \
          -t ghcr.io/grymmjack/qb64pe-docker:${{ inputs.qb64pe-version }} \
          https://github.com/grymmjack/qb64pe-docker.git#main
    
    - name: Install QB64PE (macOS)
      if: inputs.platform == 'macos'
      shell: bash
      run: |
        cd /tmp
        VERSION="${{ inputs.qb64pe-version }}"
        # Remove 'v' prefix from version for filename
        VERSION_NUM="${VERSION#v}"
        curl -L "https://github.com/QB64-Phoenix-Edition/QB64pe/releases/download/${VERSION}/qb64pe_osx-${VERSION_NUM}.tar.gz" -o qb64pe.tar.gz
        tar -xzf qb64pe.tar.gz
        cd qb64pe
        # Pass 1 to prevent IDE from launching
        ./setup_osx.command 1
        echo "QB64PE=/tmp/qb64pe/qb64pe" >> $GITHUB_ENV
    
    - name: Install QB64PE (Windows)
      if: inputs.platform == 'windows'
      shell: pwsh
      run: |
        $version = "${{ inputs.qb64pe-version }}"
        # Remove 'v' prefix from version for filename
        $versionNum = $version -replace '^v', ''
        Invoke-WebRequest -Uri "https://github.com/QB64-Phoenix-Edition/QB64pe/releases/download/$version/qb64pe_win-x64-${versionNum}.7z" -OutFile qb64pe.7z
        7z x qb64pe.7z
        cd qb64pe
        # Windows release is pre-compiled, no setup needed
        $qb64pePath = (Get-Location).Path
        echo "QB64PE=$qb64pePath\qb64pe.exe" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    
    - name: Compile QB64 program (Linux)
      if: inputs.platform == 'linux'
      shell: bash
      run: |
        docker run --rm \
          -v "${{ github.workspace }}:/workspace" \
          ghcr.io/grymmjack/qb64pe-docker:${{ inputs.qb64pe-version }} \
          -x -w "${{ inputs.source-file }}" -o "${{ env.EXECUTABLE }}"
    
    - name: Compile QB64 program (macOS/Windows)
      if: inputs.platform != 'linux'
      shell: ${{ inputs.platform == 'windows' && 'pwsh' || 'bash' }}
      run: |
        cd "${{ github.workspace }}"
        ${{ inputs.platform == 'windows' && '& ' || '' }}${{ env.QB64PE }} -x -w "${{ inputs.source-file }}" -o "${{ env.EXECUTABLE }}"
    
    - name: Prepare release package (Linux/macOS)
      if: inputs.platform != 'windows'
      shell: bash
      run: |
        cd "${{ github.workspace }}"
        
        # Create temporary packaging directory
        PACKAGE_DIR="${{ inputs.project-name }}-package"
        mkdir -p "$PACKAGE_DIR"
        
        # Build default exclusions
        EXCLUDE_ARGS=""
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='*.bas' --exclude='*.BAS'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='*.bi' --exclude='*.BI'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='*.bm' --exclude='*.BM'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='*.frm' --exclude='*.FRM'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='.git/'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='.gitmodules'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='submodules/'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='.qb64pe-ignore'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='*.7z'"
        EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='qb64pe/'"
        
        # Read .qb64pe-ignore if it exists
        if [ -f ".qb64pe-ignore" ]; then
          echo "Found .qb64pe-ignore file, processing exclusions..."
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and comments
            if [ -n "$line" ] && [[ ! "$line" =~ ^[[:space:]]*# ]]; then
              # Remove leading/trailing whitespace
              pattern=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              if [ -n "$pattern" ]; then
                EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='$pattern'"
                echo "  Excluding: $pattern"
              fi
            fi
          done < ".qb64pe-ignore"
        fi
        
        # Copy all files except excluded ones
        eval rsync -av $EXCLUDE_ARGS ./ "$PACKAGE_DIR/"
        
        # Copy the compiled executable to the package
        cp "${{ env.EXECUTABLE }}" "$PACKAGE_DIR/"
        
        # Create archive from the package directory
        tar -czf "${{ env.ARCHIVE }}" -C "$PACKAGE_DIR" .
        
        # Cleanup
        rm -rf "$PACKAGE_DIR"
    
    - name: Prepare release package (Windows)
      if: inputs.platform == 'windows'
      shell: pwsh
      run: |
        cd "${{ github.workspace }}"
        
        # Create temporary packaging directory
        $packageDir = "${{ inputs.project-name }}-package"
        New-Item -ItemType Directory -Force -Path $packageDir | Out-Null
        
        # Define default exclusion patterns (case insensitive)
        $excludePatterns = @(
          '*.bas', '*.bi', '*.bm', '*.frm',
          '.git', '.gitmodules', 'submodules',
          '.qb64pe-ignore', '*.7z', 'qb64pe'
        )
        
        # Read .qb64pe-ignore if it exists
        if (Test-Path ".qb64pe-ignore") {
          Write-Host "Found .qb64pe-ignore file, processing exclusions..."
          Get-Content ".qb64pe-ignore" | ForEach-Object {
            $line = $_.Trim()
            # Skip empty lines and comments
            if ($line -and -not $line.StartsWith('#')) {
              $excludePatterns += $line
              Write-Host "  Excluding: $line"
            }
          }
        }
        
        # Function to check if path matches any exclude pattern
        function Test-ShouldExclude {
          param($path, $name, $patterns)
          foreach ($pattern in $patterns) {
            # Handle directory patterns (ending with /)
            if ($pattern.EndsWith('/')) {
              $dirPattern = $pattern.TrimEnd('/')
              if ($path -like "*\$dirPattern" -or $path -like "*\$dirPattern\*" -or $name -eq $dirPattern) {
                return $true
              }
            }
            # Handle wildcard patterns
            elseif ($pattern.Contains('*')) {
              if ($name -like $pattern -or $path -like "*$pattern*") {
                return $true
              }
            }
            # Handle exact matches
            else {
              if ($name -eq $pattern -or $path -like "*\$pattern" -or $path -like "*\$pattern\*") {
                return $true
              }
            }
          }
          return $false
        }
        
        # Copy all items except excluded ones
        Get-ChildItem -Path . -Recurse | ForEach-Object {
          $relativePath = $_.FullName.Substring($PWD.Path.Length + 1)
          $shouldExclude = Test-ShouldExclude -path $relativePath -name $_.Name -patterns $excludePatterns
          
          if (-not $shouldExclude -and $_.FullName -notlike "*$packageDir*") {
            $destPath = Join-Path $packageDir $relativePath
            $destDir = Split-Path $destPath -Parent
            
            if (-not (Test-Path $destDir)) {
              New-Item -ItemType Directory -Force -Path $destDir | Out-Null
            }
            
            if ($_.PSIsContainer) {
              if (-not (Test-Path $destPath)) {
                New-Item -ItemType Directory -Force -Path $destPath | Out-Null
              }
            } else {
              Copy-Item $_.FullName -Destination $destPath -Force
            }
          }
        }
        
        # Copy the compiled executable to the package
        Copy-Item "${{ env.EXECUTABLE }}" -Destination "$packageDir/" -Force
        
        # Create archive from the package directory
        Compress-Archive -Path "$packageDir\*" -DestinationPath "${{ env.ARCHIVE }}" -Force
        
        # Cleanup
        Remove-Item -Recurse -Force $packageDir
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.project-name }}-${{ inputs.platform }}
        path: ${{ github.workspace }}/${{ env.ARCHIVE }}
