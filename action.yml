name: 'QB64PE Multi-Platform Build'
description: 'Build QB64PE projects for Linux, macOS, and Windows with automatic releases'
author: 'grymmjack'

branding:
  icon: 'code'
  color: 'blue'

inputs:
  source-file:
    description: 'Path to the .bas source file to compile (relative to workspace)'
    required: true
  project-name:
    description: 'Name of your project (used for artifacts and releases)'
    required: true
  qb64pe-version:
    description: 'QB64PE version to use'
    required: false
    default: 'v4.3.0'
  platform:
    description: 'Target platform: linux, macos, or windows'
    required: true

outputs:
  artifact-name:
    description: 'Name of the uploaded artifact'
    value: ${{ steps.set-names.outputs.artifact-name }}
  executable-name:
    description: 'Name of the compiled executable'
    value: ${{ steps.set-names.outputs.executable-name }}

runs:
  using: 'composite'
  steps:
    - name: Set platform-specific names
      id: set-names
      shell: bash
      run: |
        PLATFORM="${{ inputs.platform }}"
        PROJECT="${{ inputs.project-name }}"
        
        if [ "$PLATFORM" = "windows" ]; then
          EXECUTABLE="${PROJECT}.exe"
          ARCHIVE="${PROJECT}-win-x64.zip"
        elif [ "$PLATFORM" = "macos" ]; then
          EXECUTABLE="${PROJECT}"
          ARCHIVE="${PROJECT}-osx-x64.tar.gz"
        else
          EXECUTABLE="${PROJECT}"
          ARCHIVE="${PROJECT}-lnx-x64.tar.gz"
        fi
        
        echo "executable-name=${EXECUTABLE}" >> $GITHUB_OUTPUT
        echo "artifact-name=${ARCHIVE}" >> $GITHUB_OUTPUT
        echo "EXECUTABLE=${EXECUTABLE}" >> $GITHUB_ENV
        echo "ARCHIVE=${ARCHIVE}" >> $GITHUB_ENV
    
    - name: Install QB64PE (Linux)
      if: inputs.platform == 'linux'
      shell: bash
      run: |
        docker pull ghcr.io/grymmjack/qb64pe:${{ inputs.qb64pe-version }} || \
        docker build --build-arg QB64PE_VERSION=${{ inputs.qb64pe-version }} \
          -t ghcr.io/grymmjack/qb64pe:${{ inputs.qb64pe-version }} \
          https://github.com/grymmjack/qb64pe-docker.git#main
    
    - name: Install QB64PE (macOS)
      if: inputs.platform == 'macos'
      shell: bash
      run: |
        cd /tmp
        VERSION="${{ inputs.qb64pe-version }}"
        # Remove 'v' prefix from version for filename
        VERSION_NUM="${VERSION#v}"
        curl -L "https://github.com/QB64-Phoenix-Edition/QB64pe/releases/download/${VERSION}/qb64pe_osx-${VERSION_NUM}.tar.gz" -o qb64pe.tar.gz
        tar -xzf qb64pe.tar.gz
        cd qb64pe
        # Pass 1 to prevent IDE from launching
        ./setup_osx.command 1
        echo "QB64PE=/tmp/qb64pe/qb64pe" >> $GITHUB_ENV
    
    - name: Install QB64PE (Windows)
      if: inputs.platform == 'windows'
      shell: pwsh
      run: |
        $version = "${{ inputs.qb64pe-version }}"
        # Remove 'v' prefix from version for filename
        $versionNum = $version -replace '^v', ''
        Invoke-WebRequest -Uri "https://github.com/QB64-Phoenix-Edition/QB64pe/releases/download/$version/qb64pe_win-x64-${versionNum}.7z" -OutFile qb64pe.7z
        7z x qb64pe.7z
        cd qb64pe
        # Windows release is pre-compiled, no setup needed
        $qb64pePath = (Get-Location).Path
        echo "QB64PE=$qb64pePath\qb64pe.exe" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    
    - name: Compile QB64 program (Linux)
      if: inputs.platform == 'linux'
      shell: bash
      run: |
        docker run --rm \
          -v "${{ github.workspace }}:/workspace" \
          ghcr.io/grymmjack/qb64pe:${{ inputs.qb64pe-version }} \
          -x -w "${{ inputs.source-file }}" -o "${{ env.EXECUTABLE }}"
    
    - name: Compile QB64 program (macOS/Windows)
      if: inputs.platform != 'linux'
      shell: ${{ inputs.platform == 'windows' && 'pwsh' || 'bash' }}
      run: |
        cd "${{ github.workspace }}"
        ${{ inputs.platform == 'windows' && '& ' || '' }}${{ env.QB64PE }} -x -w "${{ inputs.source-file }}" -o "${{ env.EXECUTABLE }}"
    
    - name: Prepare release package (Linux/macOS)
      if: inputs.platform != 'windows'
      shell: bash
      run: |
        cd "${{ github.workspace }}"
        
        # Create temporary packaging directory
        PACKAGE_DIR="${{ inputs.project-name }}-package"
        mkdir -p "$PACKAGE_DIR"
        
        # Copy all files except source code, submodules, and git files
        rsync -av \
          --exclude='*.bas' --exclude='*.BAS' \
          --exclude='*.bi' --exclude='*.BI' \
          --exclude='*.bm' --exclude='*.BM' \
          --exclude='*.frm' --exclude='*.FRM' \
          --exclude='.git/' \
          --exclude='.gitmodules' \
          --exclude='submodules/' \
          ./ "$PACKAGE_DIR/"
        
        # Copy the compiled executable to the package
        cp "${{ env.EXECUTABLE }}" "$PACKAGE_DIR/"
        
        # Create archive from the package directory
        tar -czf "${{ env.ARCHIVE }}" -C "$PACKAGE_DIR" .
        
        # Cleanup
        rm -rf "$PACKAGE_DIR"
    
    - name: Prepare release package (Windows)
      if: inputs.platform == 'windows'
      shell: pwsh
      run: |
        cd "${{ github.workspace }}"
        
        # Create temporary packaging directory
        $packageDir = "${{ inputs.project-name }}-package"
        New-Item -ItemType Directory -Force -Path $packageDir | Out-Null
        
        # Define exclusion patterns (case insensitive)
        $excludePatterns = @(
          '*.bas', '*.bi', '*.bm', '*.frm',
          '.git', '.gitmodules', 'submodules'
        )
        
        # Copy all items except excluded ones
        Get-ChildItem -Path . -Recurse | ForEach-Object {
          $relativePath = $_.FullName.Substring($PWD.Path.Length + 1)
          $shouldExclude = $false
          
          foreach ($pattern in $excludePatterns) {
            if ($_.Name -like $pattern -or $relativePath -like "*$pattern*") {
              $shouldExclude = $true
              break
            }
          }
          
          if (-not $shouldExclude -and $_.FullName -notlike "*$packageDir*") {
            $destPath = Join-Path $packageDir $relativePath
            $destDir = Split-Path $destPath -Parent
            
            if (-not (Test-Path $destDir)) {
              New-Item -ItemType Directory -Force -Path $destDir | Out-Null
            }
            
            if ($_.PSIsContainer) {
              if (-not (Test-Path $destPath)) {
                New-Item -ItemType Directory -Force -Path $destPath | Out-Null
              }
            } else {
              Copy-Item $_.FullName -Destination $destPath -Force
            }
          }
        }
        
        # Copy the compiled executable to the package
        Copy-Item "${{ env.EXECUTABLE }}" -Destination "$packageDir/" -Force
        
        # Create archive from the package directory
        Compress-Archive -Path "$packageDir\*" -DestinationPath "${{ env.ARCHIVE }}" -Force
        
        # Cleanup
        Remove-Item -Recurse -Force $packageDir
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.project-name }}-${{ inputs.platform }}
        path: ${{ github.workspace }}/${{ env.ARCHIVE }}
